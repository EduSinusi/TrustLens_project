import os
import time
import cv2
import numpy as np
import re
import requests
import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore
from google.cloud import vision_v1
from google.cloud.vision_v1 import types
from google.oauth2 import service_account
from flask import Flask, Response, request, jsonify
from flask_cors import CORS  # Import CORS
from base64 import b64decode

# Configuration
SERVICE_ACCOUNT_FILE = r"C:\Users\USER\Desktop\trust_lens_project\TrustLens_project\OCR\triple-ranger-453716-u9-a59d61bef762.json"
SAVE_DIR = r"C:\Users\USER\Desktop\trust_lens_project\TrustLens_project\OCR\captured_images"
SAFE_BROWSING_API_KEY = "AIzaSyAvARaqeLzyvCdUfWes0wNpKpp7vYh4iuQ"  # Replace with your valid API key
SAFE_BROWSING_URL = "https://safebrowsing.googleapis.com/v4/threatMatches:find"
VALID_TLDS = {"com", "org", "net", "edu", "gov", "mil", "biz", "info", "co", "io", "ai", "app", "dev", "tech",
              "online", "store", "site", "club", "xyz", "uk", "us", "ca", "au", "de", "fr", "jp", "cn", "in",
              "br", "ru", "test", "my"}

# Initialize Flask app
app = Flask(__name__)
CORS(app, resources={r"/video_feed/*": {"origins": "http://localhost:3000"}, r"/scan_url": {"origins": "http://localhost:3000"}})  # Allow CORS for specific routes

# Initialize Firebase
cred = credentials.Certificate(r"C:\Users\USER\Desktop\trust_lens_project\TrustLens_project\OCR\trustlens-cbf72-firebase-adminsdk-fbsvc-b5be2f6954.json")
firebase_admin.initialize_app(cred)
db = firestore.client()
urls_collection = db.collection('Scanned URLs')

# Initialize Google Vision API
credentials = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE)
vision_client = vision_v1.ImageAnnotatorClient(credentials=credentials)

# Ensure save directory exists
os.makedirs(SAVE_DIR, exist_ok=True)

def preprocess_image(image):
    """Enhance image quality for better OCR results"""
    alpha = 1.5  # Contrast control
    beta = 30    # Brightness control
    adjusted = cv2.convertScaleAbs(image, alpha=alpha, beta=beta)
    denoised = cv2.bilateralFilter(adjusted, d=9, sigmaColor=75, sigmaSpace=75)
    sharpen_kernel = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])
    sharpened = cv2.filter2D(denoised, -1, sharpen_kernel)
    return sharpened

def extract_url(image):
    """Extract URLs from image using Google Vision API"""
    if image is None:
        print("Image is None")
        return None

    preprocessed_img = image  # Using raw image for now, re-enable preprocessing later if needed

    success, encoded_image = cv2.imencode('.jpg', preprocessed_img)
    if not success:
        print("Failed to encode image")
        return None
    content = encoded_image.tobytes()

    image = types.Image(content=content)
    response = vision_client.text_detection(image=image)

    if response.error.message:
        print(f"Vision API error: {response.error.message}")
        return None

    text = response.text_annotations[0].description if response.text_annotations else ""
    print(f"Raw text from Vision API: '{text}'")

    url_pattern = r'(https?://[^\s]+|www\.[^\s]+|[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\.[a-zA-Z]{2})?[^\s]*)'
    match = re.search(url_pattern, text, re.IGNORECASE)
    if not match:
        print("No URL matched in text")
        return None

    url = match.group(0)
    url = re.sub(r'[.,;:!?)\]\}]+$', '', url)
    print(f"Extracted URL before protocol check: {url}")

    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url
    print(f"Extracted URL after cleaning: {url}")

    try:
        domain = url.split('/')[2] if '//' in url else url.split('/')[0]
        domain_parts = domain.split('.')
        if len(domain_parts) >= 3 and domain_parts[-2] in {'com', 'org', 'net', 'co'}:
            tld = f"{domain_parts[-2]}.{domain_parts[-1]}".lower()
        else:
            tld = domain_parts[-1].lower()
        
        if tld not in VALID_TLDS and tld not in {f"{part}.{tld}" for part in {'com', 'org', 'net', 'co'} for tld in VALID_TLDS}:
            ip_part = domain.split(':')[0]
            octets = ip_part.split('.')
            if len(octets) != 4 or not all(octet.isdigit() and 0 <= int(octet) <= 255 for octet in octets):
                print(f"Invalid TLD or IP format: {url} (TLD: {tld})")
                return None
    except Exception as e:
        print(f"URL validation error: {e}")
        return None

    return url

def check_url_safety(url: str) -> str:
    """Check URL safety using Google Safe Browsing API v4"""
    if not url:
        return "No URL to check"
    
    payload = {
        "client": {"clientId": "trustlens-project", "clientVersion": "1.0.0"},
        "threatInfo": {
            "threatTypes": ["MALWARE", "SOCIAL_ENGINEERING", "UNWANTED_SOFTWARE", "POTENTIALLY_HARMFUL_APPLICATION"],
            "platformTypes": ["ANY_PLATFORM"],
            "threatEntryTypes": ["URL"],
            "threatEntries": [{"url": url}]
        }
    }
    
    params = {"key": SAFE_BROWSING_API_KEY}
    
    try:
        response = requests.post(SAFE_BROWSING_URL, json=payload, params=params)
        response.raise_for_status()
        result = response.json()
        
        if "matches" in result:
            threats = {f"{match['threatType']} ({match['platformType']})" for match in result["matches"]}
            return f"Unsafe: {', '.join(sorted(threats))}"
        return "Safe (no threats detected)"
    except requests.exceptions.RequestException as e:
        print(f"Error checking URL safety: {e}")
        return f"Error: {str(e)}"

def store_url_in_firestore(url, safety_status):
    """Store scanned URL and its safety status in Firestore"""
    if not url:
        return
    
    data = {
        "url": url,
        "safety_status": safety_status,
        "timestamp": firestore.SERVER_TIMESTAMP,
        "is_safe": "Safe" in safety_status
    }
    
    try:
        doc_ref = urls_collection.document()
        doc_ref.set(data)
        print(f"Stored in Firestore: {data}")
    except Exception as e:
        print(f"Failed to store in Firestore: {e}")

def generate_frames(camera_index):
    """Generate video frames from the specified webcam"""
    cap = cv2.VideoCapture(camera_index)
    if not cap.isOpened():
        print(f"Failed to open webcam at index {camera_index}")
        return

    try:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            ret, buffer = cv2.imencode('.jpg', frame)
            if not ret:
                continue
            
            frame_bytes = buffer.tobytes()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
    finally:
        cap.release()

@app.route('/video_feed/<int:index>')
def video_feed(index):
    """Stream video feed from the specified camera index"""
    return Response(generate_frames(index), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/scan_url', methods=['POST'])
def scan_url():
    """Process an image and extract/check URL"""
    data = request.get_json()
    if not data or 'image' not in data:
        return jsonify({'error': 'No image data provided'}), 400

    image_data = data['image'].split(',')[1]
    image_bytes = b64decode(image_data)
    nparr = np.frombuffer(image_bytes, np.uint8)
    image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

    if image is None:
        print("Failed to decode image from request")
        return jsonify({'error': 'Failed to decode image'}), 400

    url = extract_url(image)
    print(f"Extracted URL in /scan_url: {url}")

    if not url:
        return jsonify({'url': '', 'safety_status': 'No URL detected'})

    safety_status = check_url_safety(url)
    store_url_in_firestore(url, safety_status)

    timestamp = time.strftime("%Y%m%d_%H%M%S")
    cv2.imwrite(os.path.join(SAVE_DIR, f"scanned_{timestamp}.jpg"), image)
    print(f"Image saved: scanned_{timestamp}.jpg")

    return jsonify({'url': url, 'safety_status': safety_status})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=4000, debug=True)